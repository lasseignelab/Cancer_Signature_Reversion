---
title: "220110_plier_frda"
author: "Jennifer Fisher"
date: "1/10/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# START 
    Goal/Purpose of operations: 
    Conducting Demension reduction for Transfer learning with PLIER
    
    Finished psedocode on: Date
    220110
    
    System which operations were done on:
    my laptop(on cheaha)
    
    GitHub Repo:
    Transfer_Learning_R03
    
    Docker/Singularity: 
    rstudio_tf_dr_v3
    
    Directory of operations: 
    /data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03
    
    Scripts being edited for operations:
    NA
    
    Data being used:
    recount3- tpm normalized
    recount3 is an online resource consisting of RNA-seq gene, exon, and exon-exon junction counts as well as coverage bigWig files for 8,679 and 10,088 different studies for human and mouse respectively. It is the third generation of the ReCount project and part of recount.bio.
    http://rna.recount.bio/
    ./data/recount3
    
    Papers and tools: 
    recount3- see details above 
    PLIER and MultiPLIER wrapper functions for PLIER

# STEPS
### Set working directory 
/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03

### load in data
```{r}
recount3_group1_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group1_tpm.rds")
recount3_group2_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group2_tpm.rds")
recount3_group3_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group3_tpm.rds")
recount3_group4_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group4_tpm.rds")
recount3_group5_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group5_tpm.rds")
recount3_group6_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group6_tpm.rds")
recount3_group7_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group7_tpm.rds")
recount3_group8_tpm <- readRDS("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_group8_tpm.rds")
```

```{r}
recount3_tpm <- cbind(recount3_group1_tpm, recount3_group2_tpm, recount3_group3_tpm, recount3_group4_tpm, recount3_group5_tpm, recount3_group6_tpm, recount3_group7_tpm, recount3_group8_tpm)
```

```{r}
rm(recount3_group1_tpm, recount3_group2_tpm, recount3_group3_tpm, recount3_group4_tpm, recount3_group5_tpm, recount3_group6_tpm, recount3_group7_tpm, recount3_group8_tpm)
gc()
```



```{r}
recount3_tpm<- recount3_tpm[,! is.na(recount3_tpm[1,])]
```


```{r}
library(PLIER)
```



```{r}
library(recount3)
```

```{r}
human_samples<- available_samples()
```

```{r}
human_projects<- available_projects()
```
```{r}
#SRP118922
test<- create_rse(human_projects[(human_projects$project == "SRP118922"),])
```


```{r}
gene_info <- test@rowRanges
rm(test)
```


```{r}
human_samples_not_frda<- human_samples$external_id[!(human_samples$project == "SRP118922" | human_samples$file_source == "tcga")]
```

```{r}
recount3_wo_frda_tpm <- recount3_tpm[, colnames(recount3_tpm) %in% human_samples_not_frda]
```

```{r}
rm(human_samples, human_samples_not_gbm, recount3_tpm)
gc()
```

```{r}
recount3_wo_frda_tpm<- as.matrix(recount3_wo_frda_tpm)
rownames(recount3_wo_frda_tpm) <- gene_info$gene_name
```

```{r}
source("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/script/plier_util.R")
```

```{r}
PLIERNewData_JLF <- function(exprs.mat, seed = 12345) {
  # A wrapper function for applying PLIER to a data set. We use the following
  # genesets that come with PLIER: bloodCellMarkersIRISDMAP, svmMarkers, 
  # and canonicalPathways. We set the k parameter for the PLIER model by
  # identifying the number of "significant PCs" with PLIER::num.pc and then 
  # using sig PCs * 0.3. This is consistent with recommendations from the 
  # PLIER authors.
  # 
  # Args:
  #   exprs.mat: a gene expression matrix, rows are genes, columns are samples
  #   seed: an integer to be supplied to set.seed() for reproducibility 
  #         purposes, default is 12345
  #         
  # Returns:
  #   plier.res: output from PLIER::PLIER()
  #
  require(PLIER)
  
  set.seed(seed)
  
  # load PLIER pathway and cell type data
  data(bloodCellMarkersIRISDMAP)
  data(svmMarkers)
  data(canonicalPathways)
  
  print("combine the pathway data from PLIER")
  all.paths <- PLIER::combinePaths(bloodCellMarkersIRISDMAP, svmMarkers, 
                                   canonicalPathways)
  
  # what genes are common to the pathway data and the expression matrix
  cm.genes <- PLIER::commonRows(all.paths, exprs.mat)
  
  print(" row normalize")
  exprs.norm <- PLIER::rowNorm(exprs.mat)
  
  # what should we set the minimum k parameter to in PLIER? estimate the number 
  # of PC for the SVD decomposition 
  print("num.pc")
  mtx <- exprs.norm[cm.genes, ]
  mtx<- mtx[complete.cases(mtx),]
  set.k <- PLIER::num.pc(mtx )
  #too  long to run for test 
  #set.k<- 612
  # PLIER main function + return results
  print("PLIER main function")
  plier.res <- PLIER::PLIER(mtx, all.paths[cm.genes, ], scale= F,
                           k = round((set.k + set.k * 0.3), 0), trace = TRUE)
  
  return(plier.res)
  
}
```

```{r}
rm(gene_info, human_projects, human_samples_not_frda)
gc()
```

```{r}
recount3_plier_frda <- PLIERNewData_JLF(recount3_wo_frda_tpm)

saveRDS(recount3_plier_frda, "/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/data/recount3/recount3_plier_frda.rds")
```


Debug  LATER



```{r}
source("/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/script/220120_plier_functions_debugging.R")
```


```{r}
PLIER_JLF=function(data, priorMat,svdres=NULL, k=NULL, L1=NULL, L2=NULL, L3=NULL,  frac=0.7,  max.iter=350, trace=F, scale=T, Chat=NULL, maxPath=10, doCrossval=T, penalty.factor=rep(1,ncol(priorMat)), glm_alpha=0.9, minGenes=10, tol=1e-6, seed=123456, allGenes=F, rseed=NULL, pathwaySelection=c("complete", "fast")){
  
  pathwaySelection=match.arg(pathwaySelection, c("complete", "fast"))
  if(scale){
    Y=rowNorm(data)
  }
  else{
    Y=data
  }
  
  if(nrow(priorMat)!=nrow(data) || !all(rownames(priorMat)==rownames(data))){
    if(!allGenes){
      cm=commonRows(data, priorMat)
      message(paste("Selecting common genes:", length(cm)))
      priorMat=priorMat[cm,]
      Y=Y[cm,]
    }
    else{
      extra.genes=setdiff(rownames(data), rownames(priorMat))
      eMat=matrix(0, nrow=length(extra.genes), ncol=ncol(priorMat))
      rownames(eMat)=extra.genes
      priorMat=rbind(priorMat, eMat)
      priorMat=priorMat[rownames(data),]
    }
    
  }
  numGenes=colSums(priorMat)
  
  heldOutGenes=list()
  iibad=which(numGenes<minGenes)
  priorMat[, iibad]=0
  message(paste("Removing", length(iibad), "pathways with too few genes"))
  if(doCrossval){
    
    priorMatCV=priorMat
    if(!is.null(seed))
      set.seed(seed)
    for(j in 1:ncol(priorMatCV)){
      
      iipos=which(priorMatCV[,j]>0)
      iiposs=sample(iipos, length(iipos)/5)
      priorMatCV[iiposs,j]=0
      heldOutGenes[[colnames(priorMat)[j]]]=rownames(priorMat)[iiposs]
      
    }
    C = priorMatCV
  }
  else{
    C=priorMat
  }
  
  nc=ncol(priorMat)
  ng=nrow(data)
  ns=ncol(data)
  
  Bdiff=-1
  BdiffTrace=double()
  BdiffCount=0
  if(is.null(Chat)){
    Cp=crossprod(C)
    Chat=pinv.ridge(crossprod(C), 5)%*%(t(C))
  }
  YsqSum=sum(Y^2)
  #compute svd and use that as the starting point
  
  if(!is.null(svdres) && nrow(svdres$v)!=ncol(Y)){
    message("SVD V has the wrong number of columns")
    svdres=NULL
  }
  if(is.null(svdres)){
    message("Computing SVD")
    if(ns>500){
      message("Using rsvd")
      set.seed(123456);svdres=rsvd(Y, k=min(ns, max(200, ns/4)), q=3)
    }
    else{
      svdres=svd(Y)
    }
    message("Done")
  }
  if(is.null(k)){
    k=num.pc(svdres)*2
    k <- min(k, floor(ncol(Y)*0.9))
    message("k is set to ", k)
  }
  
  if(is.null(L2)){
    show(svdres$d[k])
    L2=svdres$d[k]
    print(paste0("L2 is set to ",L2))
  }
  if(is.null(L1)){
    L1=L2/2
    print(paste0("L1 is set to ",L1))
  }
  
  
  B=t(svdres$v[1:ncol(Y), 1:k]%*%diag(svdres$d[1:k]))
  Z=(Y%*%t(B))%*%solve(tcrossprod(B)+L1*diag(k))
  Z[Z<0]=0
  if(!is.null(rseed)){
    message("using random start")
    set.seed(rseed)
    B=t(apply(B, 1, sample))
    Z=apply(Z,2,sample)
  }
  
  U=matrix(0,nrow=ncol(C), ncol=k)
  
  
  round2=function(x){signif(x,4)}
  message(paste0("errorY (SVD based:best possible) = ", round2(mean((Y-Z%*%B)^2))))

  iter.full.start=iter.full=20
  
  curfrac=0
  nposlast=Inf
  npos=-Inf
  if(!is.null(L3)){
    L3.given=T
  }
  else{
    L3.given=F
  }
  
  for ( i in 1:max.iter){
    
    
    
    
    
    if(i>=iter.full.start){
      
      
      
      
      
      if(i==iter.full & !L3.given){ #update L3 to the target fraction
        Ulist=solveU(Z, Chat, C, penalty.factor, pathwaySelection, glm_alpha, maxPath, target.frac = frac)
    U=Ulist$U
    L3=Ulist$L3
   message(paste("New L3 is", L3))
   iter.full=iter.full+iter.full.start
          }
      else{
      #HERE
      
      #solveU=function(Z,  Chat, priorMat, penalty.factor,pathwaySelection="fast", glm_alpha=0.9, maxPath=10, target.frac=0.7, L3=NULL)
      #save(Z, Chat, C, pentalty.factor, pathwaySelection, glm_alpha, mathPath, L3, file= "/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/u_function_FRDA_input.RData" )
       save.image(file="/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/u_function_FRDA_input.RData")
        
      print("ERROR HERE")  
      U=solveU(Z, Chat, C, penalty.factor, pathwaySelection, glm_alpha, maxPath, L3=L3)
      }
      curfrac=(npos<-sum(apply(U,2,max)>0))/k
      Z1=Y%*%t(B)
      Z2=L1*C%*%U
      ratio=median((Z2/Z1)[Z2>0&Z1>0])
      Z=(Z1+Z2)%*%solve(tcrossprod(B)+L1*diag(k))
    }
    
    else{
      Z=(Y%*%t(B))%*%solve(tcrossprod(B)+L1*diag(k))
    }
    
    
    Z[Z<0]=0
    
    
    oldB=B
    B=solve(t(Z)%*%Z+L2*diag(k))%*%t(Z)%*%Y
    
    
    
    
    Bdiff=sum((B-oldB)^2)/sum(B^2)
    BdiffTrace=c(BdiffTrace, Bdiff)
    
    
    err0=sum((Y-Z%*%B)^2)+sum((Z-C%*%U)^2)*L1+sum(B^2)*L2
    if(trace & i >=iter.full.start){
      
      message(paste0("iter",i, " errorY= ",erry<-round2(mean((Y-Z%*%B)^2)), ", prior information ratio= ", round(ratio,2), ", Bdiff= ",round2(Bdiff), ", Bkappa=", round2(kappa(B))), ";pos. col. U=", sum(colSums(U)>0))
    }
    else if (trace){
      message(paste0("iter",i, " errorY= ",erry<-round2(mean((Y-Z%*%B)^2)), ", Bdiff= ",round2(Bdiff), ", Bkappa=", round2(kappa(B))))
    }
    
    if(i>52&&Bdiff>BdiffTrace[i-50]){
      BdiffCount=BdiffCount+1
      message("Bdiff is not decreasing")
    }
    else if(BdiffCount>1){
      BdiffCount=BdiffCount-1
    }
    
    if(Bdiff<tol){
      message(paste0("converged at  iteration ", i))
      break
    }
    if( BdiffCount>5){
      message(paste0("converged at  iteration ", i, " Bdiff is not decreasing"))
      break
    }
    
  }
  rownames(U)=colnames(priorMat)
  colnames(U)=rownames(B)=paste0("LV", 1:k)
  
  out=list(residual=(Y-Z%*%B), B=B, Z=Z, U=U, C=C, L1=L1, L2=L2, L3=L3, heldOutGenes=heldOutGenes)
  
  if(doCrossval){
    outAUC=crossVal(out, Y, priorMat, priorMatCV)
  }
  else{
    message("Not using cross-validation. AUCs and p-values may be over-optimistic")
    outAUC=getAUC(out, Y, priorMat)
  }
  out$withPrior=which(colSums(out$U)>0)
  out$Uauc=outAUC$Uauc
  out$Up=outAUC$Upval
  out$summary=outAUC$summary
  tt=apply(out$Uauc,2,max)
  message(paste("There are", sum(tt>0.70), " LVs with AUC>0.70"))
  
  rownames(out$B)=nameB(out)
  
  out
}

```

```{r}
exprs.mat<- recount3_wo_frda_tpm
 set.seed(12345)
# # load PLIER pathway and cell type data
   data(bloodCellMarkersIRISDMAP)
   data(svmMarkers)
   data(canonicalPathways)
  
  print("combine the pathway data from PLIER")
  all.paths <- PLIER::combinePaths(bloodCellMarkersIRISDMAP, svmMarkers, 
                                   canonicalPathways)
  # what genes are common to the pathway data and the expression matrix
    cm.genes <- PLIER::commonRows(all.paths, exprs.mat)
  
  print(" row normalize")
  exprs.norm <- PLIER::rowNorm(exprs.mat)
  saveRDS(exprs.norm ,file= "/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/PLIER_debugging_exprs_norm.rds" )
  # what should we set the minimum k parameter to in PLIER? estimate the number 
  # of PC for the SVD decomposition 
  print("num.pc")
  mtx <- exprs.norm[cm.genes, ]
  mtx<- mtx[complete.cases(mtx),]
  #set.k <- PLIER::num.pc(mtx )
  save(mtx, all.paths, cm.genes, file= "/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/PLIER_function_FRDA_input.RData" )
  set.k<- 612
  print("PLIER_JLF main function")
  plier.res <- PLIER_JLF(mtx, all.paths[cm.genes, ], scale= F,
                           k = round((set.k + set.k * 0.3), 0), trace = TRUE)
 # Selecting common genes: 6379
#Removing 5 pathways with too few genes
#Computing SVD
#Using rsvd
#Done
#Error in PLIER_JLF(mtx, all.paths[cm.genes, ], scale = F, k = round((set.k +  : 
#  object 'set.k' not found
  info<- sessionInfo()
  saveRDS(info,file= "/data/project/lasseigne_lab/JLF_scratch/Transfer_Learning_R03/PLIER_debugging_Info.rds" )
```





